/**
 * Multilingual memory triggers and category/decay keywords.
 * English is the single source of truth (hardcoded). Other languages are loaded from
 * .language-keywords.json (generated by `openclaw hybrid-mem build-languages`).
 * Used for shouldCapture, detectCategory, and decay classification.
 */

import { readFileSync, existsSync } from "node:fs";
import { join } from "node:path";

const LANG_FILE_NAME = ".language-keywords.json";

/** English-only keywords (single source of truth). Other languages are added from file. */
export const ENGLISH_KEYWORDS = {
  triggers: [
    "remember", "prefer", "decided", "my", "is my", "i like", "i prefer", "i hate", "i love", "i want", "i need",
    "always", "never", "important", "born on", "birthday", "lives in", "works at",
    "password is", "api key", "token is", "chose", "selected", "went with", "picked",
    "because", "since", "for", "architecture", "stack", "approach",
  ],
  categoryDecision: [
    "decided", "chose", "went with", "selected", "always use", "never use",
    "over because", "instead of since", "will use",
  ],
  categoryPreference: ["prefer", "like", "love", "hate", "want"],
  categoryEntity: ["is called", "email", "phone"],
  categoryFact: ["born", "birthday", "lives", "works", "is ", "are ", "has ", "have "],
  decayPermanent: ["decided", "architecture", "always use", "never use"],
  decaySession: ["currently debugging", "right now", "this session"],
  decayActive: ["working on", "need to", "todo", "blocker", "sprint"],
  /** Self-correction detection (issue #34). Phrases that suggest the user is correcting the agent. Translated via build-languages for multi-language support. */
  correctionSignals: [
    "every time",
    "i already told",
    "you should have",
    "why don't you",
    "why are you not",
    "help me understand why",
    "i have to nudge",
    "would have expected",
    "you have password",
    "you have credentials",
    "you have token",
    "lets revert",
    "let's revert",
    "that was wrong",
    "you misunderstood",
    "been waiting",
    "not automatically progress",
    "same mistake",
    "try again",
    "why can't you",
    "why cant you",
    "just ssh",
    "just check",
    "just use",
    "just do",
  ],
} as const;

export type KeywordGroup = keyof typeof ENGLISH_KEYWORDS;

export type LanguageKeywordsFile = {
  version: number;
  detectedAt: string;
  topLanguages: string[];
  translations: Record<string, Record<KeywordGroup, string[]>>;
  /** v2: per-language structural trigger phrases (e.g. "I prefer X", "my X is Y") merged into trigger regex. */
  triggerStructures?: Record<string, string[]>;
  /** v2: per-language extraction building blocks; runtime builds safe regex from these. */
  extraction?: Record<string, LanguageExtractionTemplate>;
};

/** Building blocks for structured fact extraction in a given language (verbs, connectors, etc.). */
export type LanguageExtractionTemplate = {
  decision?: { verbs: string[]; connectors: string[] };
  choiceOver?: { verbs: string[]; rejectors: string[]; connectors: string[] };
  convention?: { always: string[]; never: string[] };
  possessive?: { possessiveWords: string[]; isWords: string[] };
  preference?: { subject: string[]; verbs: string[] };
  nameIntro?: { verbs: string[] };
};

export type MergedKeywords = Record<KeywordGroup, string[]>;

let keywordsPath: string | null = null;

/** Set directory containing .language-keywords.json (e.g. dirname of facts.db). Call at plugin init. Pass empty string to clear (e.g. in tests). */
export function setKeywordsPath(dirPath: string): void {
  keywordsPath = dirPath === "" ? null : dirPath;
}

export function getKeywordsPath(): string | null {
  return keywordsPath;
}

/** Full path to .language-keywords.json, or null if path not set. */
export function getLanguageKeywordsFilePath(): string | null {
  if (!keywordsPath) return null;
  return join(keywordsPath, LANG_FILE_NAME);
}

let cache: { merged: MergedKeywords; path: string; triggerStructures: string[]; extraction: Record<string, LanguageExtractionTemplate> } | null = null;

function escapeRegex(s: string): string {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function mergeGroup(
  english: readonly string[],
  translationsByLang: Record<string, Record<string, string[]>> | undefined,
  group: KeywordGroup,
): string[] {
  const set = new Set<string>(english);
  if (translationsByLang) {
    for (const langData of Object.values(translationsByLang)) {
      const list = langData?.[group];
      if (Array.isArray(list)) for (const w of list) if (typeof w === "string" && w.trim()) set.add(w.trim());
    }
  }
  return [...set];
}

/** Load merged keywords (English + file). Returns English-only if file missing. */
export function loadMergedKeywords(): MergedKeywords {
  const path = keywordsPath;
  if (!path) {
    cache = null;
    return Object.fromEntries(
      (Object.keys(ENGLISH_KEYWORDS) as KeywordGroup[]).map((k) => [k, [...ENGLISH_KEYWORDS[k]]]),
    ) as MergedKeywords;
  }
  const filePath = join(path, LANG_FILE_NAME);
  if (cache && cache.path === filePath) return cache.merged;

  let data: LanguageKeywordsFile | null = null;
  if (existsSync(filePath)) {
    try {
      const raw = readFileSync(filePath, "utf8");
      data = JSON.parse(raw) as LanguageKeywordsFile;
    } catch {
      // invalid or missing: use English only
    }
  }

  const merged: MergedKeywords = {} as MergedKeywords;
  for (const group of Object.keys(ENGLISH_KEYWORDS) as KeywordGroup[]) {
    const english = ENGLISH_KEYWORDS[group];
    merged[group] = mergeGroup(english, data?.translations ?? undefined, group);
  }
  const triggerStructures: string[] = [];
  if (data?.triggerStructures && typeof data.triggerStructures === "object") {
    for (const list of Object.values(data.triggerStructures)) {
      if (Array.isArray(list)) for (const s of list) if (typeof s === "string" && s.trim()) triggerStructures.push(s.trim());
    }
  }
  const extraction: Record<string, LanguageExtractionTemplate> =
    data?.extraction && typeof data.extraction === "object" ? (data.extraction as Record<string, LanguageExtractionTemplate>) : {};
  cache = { merged, path: filePath, triggerStructures, extraction };
  return cache.merged;
}

/** Clear cached merged keywords (e.g. after writing new file or in tests). */
export function clearKeywordCache(): void {
  cache = null;
}

function buildRegexFromKeywords(keywords: string[]): RegExp {
  if (keywords.length === 0) return /(?!.)/; // never match
  const escaped = keywords.map(escapeRegex).filter((s) => s.length > 0);
  return new RegExp(escaped.join("|"), "i");
}

/** Memory trigger regexes for shouldCapture. Includes merged keywords, optional structural phrases from file, and universal patterns (phone, email). */
export function getMemoryTriggerRegexes(): RegExp[] {
  const merged = loadMergedKeywords();
  const triggerWords = merged.triggers;
  const phraseRegex = buildRegexFromKeywords(triggerWords);
  const list: RegExp[] = [
    phraseRegex,
    /\+\d{10,}/,
    /[\w.-]+@[\w.-]+\.\w+/,
  ];
  if (cache?.triggerStructures && cache.triggerStructures.length > 0) {
    list.push(buildRegexFromKeywords(cache.triggerStructures));
  } else {
    list.push(/\bmy\s+\w+\s+is\b|\bis\s+my\b/i, /\bi\s+(like|prefer|hate|love|want|need)\b/i, /\balways\b.*\buse\b|\bnever\b.*\buse\b/i);
  }
  return list;
}

/** Per-language extraction templates from .language-keywords.json (v2). Empty if file missing or no extraction. */
export function getExtractionTemplates(): Record<string, LanguageExtractionTemplate> {
  if (!keywordsPath) return {};
  const filePath = join(keywordsPath, LANG_FILE_NAME);
  if (cache?.path !== filePath) loadMergedKeywords();
  return cache?.extraction ?? {};
}

export function getCategoryDecisionRegex(): RegExp {
  return buildRegexFromKeywords(loadMergedKeywords().categoryDecision);
}

export function getCategoryPreferenceRegex(): RegExp {
  return buildRegexFromKeywords(loadMergedKeywords().categoryPreference);
}

export function getCategoryEntityRegex(): RegExp {
  const merged = loadMergedKeywords();
  const entityWords = merged.categoryEntity;
  return new RegExp(
    `\\+\\d{10,}|@[\\w.-]+\\.\\w+|${entityWords.map(escapeRegex).join("|")}`,
    "i",
  );
}

export function getCategoryFactRegex(): RegExp {
  return buildRegexFromKeywords(loadMergedKeywords().categoryFact);
}

export function getDecayPermanentRegex(): RegExp {
  return buildRegexFromKeywords(loadMergedKeywords().decayPermanent);
}

export function getDecaySessionRegex(): RegExp {
  return buildRegexFromKeywords(loadMergedKeywords().decaySession);
}

export function getDecayActiveRegex(): RegExp {
  return buildRegexFromKeywords(loadMergedKeywords().decayActive);
}

/** Regex to detect user messages that look like corrections/nudges (issue #34). Uses English + translated correctionSignals from .language-keywords.json after build-languages. */
export function getCorrectionSignalRegex(): RegExp {
  return buildRegexFromKeywords(loadMergedKeywords().correctionSignals);
}
